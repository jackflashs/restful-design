既然已经约定好了接口，那后端的任务就是根据这个约定，返回对应的结果
---------
> 一个标准的业务系统代码：nodejs + vue 为例
### 流程: 
##### model - service - controller - 网络传输 - sdk - store - template
### 模块: 
##### 层下划分，建议在同一层在划分一个模块出来，在下眼神不好10多个就会觉得眼花缭乱了，因此在service，model，controller下吧再把模块划分，世界就又清净了
    e.g.: 
      service - weapon
              - player
              - battle
> 如有需要进行二度划分，一般业务很少，在划分就开新系统吧
> service - item - weapon (item 模块下的 weapon 模块下的对应service) | item - service - weapon (item 系统下的 service 下的 weapon 模块)

> 这些大量的代码将花费大量的人力， 维护也将花费大量的精力，本文主要阐述的就是如何简洁化这部分代码

> 我们想网路左边的部分分割出来，成为后端。

### controller：作为入口与出口存在，需要接受参数，并返回约定结果。
#### 任务：
##### 1. 开启对应接口路径
##### 2. 参数校验，对所有必要的参数，先校验类型，在校验数据内容。一旦不符合要求，直接抛出PARAM错误结束流程。所有前端参数都在这校验，后面如果再出现参数相关问题，那就是后端自己的事情了
##### 3. 填充来自其他相关service的内容
##### 4. 处理多个不相关的流程，分别调用多个service
##### 5. 组装service结果。返回前端

      在这里把该校验的校验完毕，这样在这个功能里流入流出的数据都是完整的。不要直接在数据库操作数据。有bug的数据10有89都是直接操作数据库出来的。

### service: 
##### 如果把所有任务交给controller，就会显得controller任务过重。这时可以采用service阻断细节暴露
#### 任务：
##### 1. 逻辑操作。该计算的计算，该自动调整内容的调整，数据唯一性内容查询
> 如果不是最终数据需要的条件，先调用其他dao，拿到关联数据，再通过关联数据调用最终dao。
> 如果最终数据需要有内部类的内容，service只返回最终数据的表有的内容。填充增量内容交回给controller
##### 2. 数据库操作。算不上直接操作，但因为有mongoose-modal之类的模块，直接调用。流程也就算结束了
##### 3. 返回数据

    不要再这层再做无谓的null校验了。这是清洁代码很重要的一步。这里会出现的null，1是第三方模块的错误。2是自己程序的错误。自己程序的错误就应让他暴露出来，而不是藏起来。用一堆if掩盖


### 错误: 
##### 错误分三类，后端已经处理的错误，后端自身的错误，第三方模块的错误。这三类错误应区分返回，才能令前后端开发者发现职责所在，有效提高开发效率
#### i. 后端已处理: 
需要明确的是，后端已处理的错误并不代表没有错误，而是能让前端区别回馈给用户。经过开发，debug之后，理想状态下，所有的错误应进入此类。因此，应为所有后端统一的一类自定义错误
##### 创建时机: 
- FAIL: 操作失败，一个很普通的操作，结果是失败了，注意是结果，不是中途。

e.g.: 
> 保存，数据验证都正确，结果发现没能存进去。需要告诉用户，叫他不要放弃治疗，请稍后再试。

- PARAM: 参数校验不通过。用于后端写了校验规则，而前端没有完成的情况
> 见过有推荐使用java原生错误 IllegalArgument 的，在下不是很推荐这种做法，这里指的是业务中的参数校验，应和程序中的参数错误分离。最大好处是，明确责任在谁，前端不到位(param)还是后端代码不正确(illegalArgument)。同时以前后端分离来说，后端对前段应该透明，为什么要把后端定位为java呢，难道不能有多重语言的多个后端？难不成还要前端吧各种后端错误枚举出来？
- UNAUTH: 调用接口前middleware|interceptor拦截。特殊环境下，执行操作前在验证一次，比如本人才能更新本人数据，而不是登陆了改谁的数据都行。
- SERVICE_EXCEPTION: 正确来说，这不是一种程序上的错误，是用户操作不当，只要用户看到对应信息就好。

e.g.: 
> 比如在下只能一边手拿一把武器，如果往嘴巴装备一把武器，就会收到这个异常: NO_ZORO_ZUIDUN_ONLY

- 其他设定以外的异常: ILLEGAL_ARGUMENT, NULLPOINT, XXX IS NOT DEFINED，请保留原样。这样一看到，就可以明确，这是后端没写对。该后端改代码了
      
#### ii. 后端自身: 即时做了充足的测试，bug依然在所难免，应直接吧重要信息暴露给前端(开发阶段)从而尽早发现，尽早处理。前端发现后，通知后端人员修整
#### iii. 第三方: 其实真的很少，多数情况下是后端使用不当导致的，是的，他们会有遗漏，但是也需要不到我们去修改他的源代码。别人家有着大量顶尖技术人员在维护，不需要总是认为我们自己无所不能，好比nodejs作者，一个顶尖的开发者，依然把引擎v8交给另一个顶尖团队
#### vi. 不该为错误: 每一个操作有会有用户期望值，只要结果符合期望值，都不应该返回错误。
e.g.: 
> 最常见的是修改与删除，修改是用户期望name变为chikage，有可能因为数据值本身就是chikage，而修改失败，但这时应反馈成功。删除可能多次请求，已经被删除了，这时数据不存在就符合用户期望。完全没必要抛个异常出来留给前端做礼物。

### 增:
  手动查询一遍必要的参数是否有重复key，以便于返回给客户端分辨。
### 删:
### 改:
### 查:

### 著名的nullpoint:
#### 返回: 
##### 使用空对象代替null,前端后端都可以直接取到内部属性判断，而不是一层一层判断下去
e.g.: 
```
if (model), if(model.name) ====> if (model.name)
```
#### 校验: 
##### 不做，或少做校验，这是一个很有用的原则。把问题最大化暴露出来，以便在开发阶段处理。
> 做了nullpoint判断，发现必要参数是null，接着返回个null给调用者。调用者得到个null，然后判断一下，然后又丢了个null给上级。FUUUUUUCK，这还有完没完了？答案是：没没完~，因为最后的到结果的前端，后端，嗯，还好老子聪明，做了校验，但。。。这是从哪开始的。。。

> 更有甚者，判断了nullpoint, 然后抛出了new nullpoint...

> 错误不怕发生，就怕他不发生！发生了，就应该去找出根源在哪，而不是一段段的屏蔽掉

> 开发阶段遇不到？测试都干嘛去了？没测试人员？最基本的单元测试总要做吧

### 本类，以及父类的调用:
#### 本类: 
##### 本类可以采用this.或者是不加修饰来调用。为了充分利用默认值概念，以及简化概念。本类的调用，采用不加修饰。
#### 父类: 
##### 父类的可选项为super. 或者是不加修饰。本类确定下来后，父类就容易很多，直接采用super.让其区分明确
