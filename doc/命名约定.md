这里一般的基本规则就不提了，主要提一些如何制作成，可复制，简洁的代码

重点是：Dont repeat yourself。很多人都听说过这个原则，但有多少人在细节都采用这个原则呢。

很重要的一点，名字:

  以下代码，粗看可能会无法理解其中内容；
    const model = require('../model/player);`
    class playerService {
      save: async(e) => {
        await model.save(e)
      }
      count: async(filter) => {
        return await model.find(name: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  也许很多人一开始会喜欢以下写法
    const playerModel = require('../model/player);`
    class playerService {
      savePlayer: async(player) => {
        await playerModel.save(player)
      }
      countTotalPlayers: async(filter) => {
        return await playerModel.find(playerName: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  问题1: 当我们如果尝试添加一个新的Service的时候

  第一种:
    const model = require('../model/weapon);`
    class weaponService {
      save: async(e) => {
        await model.save(e)
      }
      count: async(filter) => {
        return await model.find(name: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }
  第二种:
    const weaponModel = require('../model/weapon);`
    class weaponService {
      saveWeapon: async(weapon) => {
        await weaponModel.save(weapon)
      }
      countTotalWeapons: async(filter) => {
        return await weaponModel.find(weaponName: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  可以发现第一种写法只需要修改引用model类型与文件名。第二种令自己忙碌了好一段

  问题2: 一开始强调的DRY原则，这里荡然无存

    第一种: 两个文件内容几乎一样，可以理解为完全在repeat self
      但是，仔细看他自己的文件，他并没有repeat自己
    第二种: 看起来没有repeat，但自己分解，其实全盘都在repeat。
      但是，他在自己文件里，一直在repeat自己
        全篇可以找得出很多个weapon单词
    
  其实只需要理解一个原则，那么第一种显然比较易于维护
    1.默认值观念: 
      比如当前例子，在weaponService文件下。那么默认值必然是weapon.那么产生的名称save(), count()其实就有迹可寻。我们展开来看： 
        weaponService.save()。对比与weaponService.saveWeapon() 这里就出现了两次weapon
      理解上的默认值: 这个名称可以比较含糊，我们通过例子来理解:
        weaponService.count() 对比与 weaponService.countTotalWeapons()中: count必然是计算数量，一定情况下的数量。total的存在显得毫无意义，因为我们不会去计算一个weapon的数量
      默认条件: 
        前两条规则，我们试着来创建一个新的方法find()。这时很容易理解是查询武器。但是比较难以理解的是，查询一个武器还是武器列表呢. 我们将它定义为列表。为的是能很好的与count对应。
          为什么一个find需要与一个count对应？首先我们，将页码交给前端，那么是需要个获得数量的接口的，同时这个获取数量的接口其实是在与find同样筛选条件下对应的数量，比如：name携带有aaa的玩家的列表，的数量
        那么我们应该如何查询一个武器呢，总不能find2()吧，还是说把id作为条件查出了列表在取第一个值吧。这时候我们应该分离一个特殊的findById()。
          这里为什么不需要findByPlayerId();这里取决于对象player {id: 还是playerId}

类名与属性名

特殊的e
  曾几何时，在下也是写着全类名度过了好几年，即使网上很多第三方模块中几个字母缩写的简写，拿到手里应用的时候，都会转为全名(fs -> fileSystem)应用到自己代码中 渐渐的发现，很，累，人。
  不只是第三方模块用得累人，自己的业务代码也写的累人。终于决定在自己修炼累死之前，探索着旁门左道以求速成，以至于现在用得是完全走火入魔了。

  采用e，而不是当前对象的名字的小写开头(weapon,person)，有如下目的:
    1.简洁: 一个字母肯定比7，8个字母来的简单，眼珠滚过1mm永远比滚过10mm要快的道理。一个字母能表达的东西，为什么要写6个字母？一个字母最大的问题就是难以理解，与其他内容混淆。看到这里明白，其实只要有一个很明确的思想去理解他，那就不难接受了
    2.易于阅读: 很多修炼多年的大侠肯定唾弃了，这个不是首字母，又不是尾字母的奇怪东西还易于阅读了。
      是的。他不是取于首字母，甚至也不似这个单词里面的任何一个字母。但是各位，请试想着当他大量出现，从而导致的各个文件大部分相同的时候: 理解一个e，就理解一个文件，理解一个文件，就理解这坨文件时候的感受
  查阅可以发现，e在英文字母里出现的几率是最大的。

  如何理解: 一个越单调的单词运用的范围越应该小，这样才能很好防止混乱以及有效复用。在下这里推荐使用的只有两个地方，方法主体中的单个实体，循环体。
      主体: 一个与上下文有着相关联内容的主体。一个方法中很大概率会围绕着一个对象操作，当然如果1000行的方法另当别论。
        e.g.: 保存武器的方法。操作: 保存-save，主体: 武器-e；修改玩家。操作: 修改-update，主体: 玩家-e。
      循环体: 循环体中的e，应理解为each。首先要说的是，循环的list就叫list，不要叫e。如果方法中已有主体使用了e，那么该改变的是循环体(比如改为each)
        e.g.: list.forEach(e => {...})
      
      这个主体需要有一个特点，必须和本方法，本类，或者是本文件有最直接的关联，如果在weaponService里面，增删改查这类操作的主体，都应该只能是weapon，
  
  刚开始可能不适应，一旦进入状态，唯一不好的地方就是，读代码的时候原本写法再也读不下去了，只想着从写一遍再去阅读！