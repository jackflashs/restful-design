这里一般的基本规则就不提了，主要提一些如何制作成，可复制，简洁的代码

重点是：Dont repeat yourself。很多人都听说过这个原则，但有多少人在细节都采用这个原则呢。

很重要的一点，名字:

  以下代码，粗看可能会无法理解其中内容；
    const model = require('../model/player);`
    class playerService {
      save: async(e) => {
        await model.save(e)
      }
      count: async(filter) => {
        return await model.find(name: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  也许很多人一开始会喜欢以下写法
    const playerModel = require('../model/player);`
    class playerService {
      savePlayer: async(player) => {
        await playerModel.save(player)
      }
      countTotalPlayers: async(filter) => {
        return await playerModel.find(playerName: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  问题1: 当我们如果尝试添加一个新的Service的时候

  第一种:
    const model = require('../model/weapon);`
    class weaponService {
      save: async(e) => {
        await model.save(e)
      }
      count: async(filter) => {
        return await model.find(name: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }
  第二种:
    const weaponModel = require('../model/weapon);`
    class weaponService {
      saveWeapon: async(weapon) => {
        await weaponModel.save(weapon)
      }
      countTotalWeapons: async(filter) => {
        return await weaponModel.find(weaponName: {$regex: `${filter.name}.*`}).skip(filter.start)
      }
    }

  可以发现第一种写法只需要修改引用model类型与文件名。第二种令自己忙碌了好一段

  问题2: 一开始强调的DRY原则，这里荡然无存

    第一种: 两个文件内容几乎一样，可以理解为完全在repeat self
      但是，仔细看他自己的文件，他并没有repeat自己
    第二种: 看起来没有repeat，但自己分解，其实全盘都在repeat。
      但是，他在自己文件里，一直在repeat自己
        全篇可以找得出很多个weapon单词
    
  其实只需要理解一个原则，那么第一种显然比较易于维护
    1.默认值观念: 
      比如当前例子，在weaponService文件下。那么默认值必然是weapon.那么产生的名称save(), count()其实就有迹可寻。我们展开来看： 
        weaponService.save()。对比与weaponService.saveWeapon() 这里就出现了两次weapon
      理解上的默认值: 这个名称可以比较含糊，我们通过例子来理解:
        weaponService.count() 对比与 weaponService.countTotalWeapons()中: count必然是计算数量，一定情况下的数量。total的存在显得毫无意义，因为我们不会去计算一个weapon的数量
      默认条件: 
        前两条规则，我们试着来创建一个新的方法find()。这时很容易理解是查询武器。但是比较难以理解的是，查询一个武器还是武器列表呢. 我们将它定义为列表。为的是能很好的与count对应。
          为什么一个find需要与一个count对应？首先我们，将页码交给前端，那么是需要个获得数量的接口的，同时这个获取数量的接口其实是在与find同样筛选条件下对应的数量，比如：name携带有aaa的玩家的列表，的数量
        那么我们应该如何查询一个武器呢，总不能find2()吧，还是说把id作为条件查出了列表在取第一个值吧。这时候我们应该分离一个特殊的findById()。
          这里为什么不需要findByPlayerId();这里取决于对象player {id: 还是playerId}

类名与属性名
