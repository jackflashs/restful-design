vuejs为例，
1.template: template是vuejs特有的(相对原生html)，通过多个template的代码来生成一个页面。一个template应包含自己的html，js以及style，而不是
  页面: 写法真心太多了，如果自己有熟练的写法的话，来得比什么框架都顺手，当然这部分其实是在设计师持有更多的股份。
    样式方面，强烈建议flex
  js: 
    1.顺序: 
      1.数据: data, props, computed.
      2.组件: components，
      3.生命周期: created, mounted, 这里去调用method，而不应该直接在这里写入具体内容
      4.方法: method，定义各种操作，事件，并dispatch action来获得后端数据
  style: 
    1.行内: 在下并不拒绝行内样式，行内样式最大的缺点是太长，论开发效率来说，行内样式离效果代码最近，因此最易阅读。加上html标签嵌套几层之后，显示结果很有可能不是层级顺序了，行内样式更能凸显开发效率。
    2.内嵌: 请加上scoped，踩过没加的坑，跑到一个样式正确的页面上，然后跑回来，这个样式页面也正确了，以至bug挖不到。
    3.外部: 把一些零散的全局样式定义好来使用，比如整个网站的蓝色应该是统一的一种，定义个c-blue是最好的选择，一旦切换，也可以全局切换
    4.顺序: 样式应遵循外到内的顺序，这样当大家统一起来后才能很快的辨识，顺序不一的乱写，就会
      1.外框: margin, pendding, 写在行内样式,其中padding尽可能用margin替代，因为padding会改变宽高
      2.大小: width, height，写在行内样式
      3.花边: background, border，box-shadow，如果有全站统一要求，写在外部样式，如果当前template有多个一样的，考虑内嵌，否则行内
      4.显示格式: display，flex, flex-direction，justify-content等, 因为全站使用flex，因此此部分写外部，零零散散一样一个属性就好，全站试用下，这些是多种组合的。
      5.内容: font-size，font-weight，color，写于外部，同显示格式，字体大小做好几个全站统一的就好，如果有10+中不同搭配，那就可以推锅给设计师了。
      6.其他: 
    5.谨慎使用: position, z-index, 
    6.不使用: float, important,
    
2.store: 项目大了以后还是需要搭配vuex来说使用的。可能在下的项目还没到巨型，依旧没能体会到mapgetter的作用。
  1.state: 可以理解为一个本地的缓存数据，页面上的动态数据都是state里的内容。
    1.CLEAN_STATE: 先给store定义一个CLEAN_STATE来设置默认值，不需要详细到每个属性，吧外框画出来就行，当需要重置的时候，通过CLEAN_STATE来获取默认值
    2.state: 这里才是运行时的数据
  2.action: 命名应该用动作，获得payload的数据，组装后给sdk，并获取的服务端结果，判断是否出错，然后提交结果集给mutations.
  3.mutations: 用于提交某项内容到state，命名应采用名词为主，而不是一个动作，同时提交的内容应尽可能的简单，少逻辑，直接赋值
    e.g.: 
      commit('detail', data)
      detail(state, e) {
        state.detail = e
      }

2.接口请求 | sdk部分: 这部分认作前端或后端sdk均可，至于sdk写法，各有千秋，总的来说，收集参数，调用地址。
  1.service: 验证必要参数，根据后端，创建formdata或者urlencoded。然后fetch指定接口。
  2.发起请求: 这里先做出一些简单的通用处理，比如参数整理，token加入，content-type处理
    通过接口约定做出的贡献，现在我们可以利用这些约束，简洁我们的代码。
    fetch: html5提供出来的原生接口，可以很好的完成restful请求
      let response = await fetch(...)
      
      如果没有response.ok, response.json()可以视为网络问题提示给用户, 这时一个try-catch + if就可以应对所有接口。把以上status稍加处理，融入自己前端code中，比如{code: -1, msg: statusText}。把他们封装起来，一个简单的库就完成了（既然一个try可以解决的问题，为什么每个调用的接口都
      要try呢。）

    xmlhttprequest: 比较古老，曾经弄过，用起来不如fetch来的流畅，但为的是得到与fetch同样的结果。与其留下一好一坏的两让人不知所措，不如只留一条明路指引人们。

2.
  但是总有人会往你的项目里面插各种传统的方式进来，这个时候则需要改造一个这个封装类，使其变为约定格式。在做返回