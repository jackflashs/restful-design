vuejs为例，
1.template: template是vuejs特有的(相对原生html)，通过多个template的代码来生成一个页面。一个template应包含自己的html，js以及style，而不是
  页面: 写法真心太多了，如果自己有熟练的写法的话，来得比什么框架都顺手，当然这部分其实是在设计师持有更多的股份。
    样式方面，强烈建议flex
    标签:
      main: 保持一个页面只有一个main标签。含括header，footer以外的内容。
      article: list页面，每一个都可以是一个article，而详情页面，那就一个article， article不建议嵌套article。
      section: 每一个有意义的模块，可以作为一个section。标题+输入框，一个search bar都可以是一个section。section可以嵌套section
      label: label标签是带有功能的，和id关联做css样式，或者是绑定内部input，不要随便用来做标题，表头之类的。div足矣
      属性: 以下排列顺序分先后
        1.v-if | v-show:
        2.class | :class
        3.style | :style
        4.id | name: 不要使用id，除非特殊第三方组件需要用到，多数情况下配合做样式，而不是值传递，
        5.v-model: 替代name做功能，mvvm的值传递
        6.其余特殊属性: autocomplete, required 写法直接required就ok了
  js: 
    1.顺序: 
      1.数据: data, props, computed.
      2.组件: components，
      3.生命周期: created, mounted, 这里去调用method，而不应该直接在这里写入具体内容
      4.方法: method，定义各种操作，事件，并dispatch action来获得后端数据
  style: 
    1.行内: 在下并不拒绝行内样式，行内样式最大的缺点是太长，论开发效率来说，行内样式离效果代码最近，因此最易阅读。加上html标签嵌套几层之后，显示结果很有可能不是层级顺序了，行内样式更能凸显开发效率。
    2.内嵌: 请加上scoped，踩过没加的坑，跑到一个样式正确的页面上，然后跑回来，这个样式页面也正确了，以至bug挖不到。 如果一个页面下有使用多个同样的样式，比如bg-grey，但是其他页面没有，那可以提出来到内嵌样式。如果其他页面也是，那么就应该是公用样式
    3.外部: 把一些零散的全局样式定义好来使用，比如整个网站的蓝色应该是统一的一种，定义个c-blue是最好的选择，一旦切换，也可以全局切换
    4.顺序: 样式应遵循外到内的顺序，这样当大家统一起来后才能很快的辨识，顺序不一的乱写，就会发生添加重复的情况。
      1.外框: margin, pendding, 写在行内样式,margin尽可能的朝向一个方向: margin-bottom,margin-right; padding尽可能用margin替代，因为padding会改变宽高
      2.大小: width, height，写在行内样式
      3.花边: background, border，box-shadow，如果有全站统一要求，写在外部样式，如果当前template有多个一样的，考虑内嵌，否则行内
      4.显示格式: display，flex, flex-direction，justify-content等, 因为全站使用flex，因此此部分写外部，零零散散一样一个属性就好，全站试用下，这些是多种组合的。
      5.内容: font-size，font-weight，color，写于外部，同显示格式，字体大小做好几个全站统一的就好，如果有10+中不同搭配，那就可以推锅给设计师了。
      6.其他: 
      7.class顺序: 根据class内容，遵从以上原则。如果是内嵌样式，则放在全局样式后面
    5.谨慎使用: position, z-index, line-height
    6.不使用: float, important,
    7.main标签: 每个主体页面，使用main标签包含起来，菜单部分，细节模块不要使用main，最终效果保持切换到哪个页面都只有一个<main>
    8.自适应: 使用flex完成大部分自适应，这样无论伸缩多大都可以有很自然的自适应，
      外部不定宽: 使用%来让容器宽度根据浏览器活动。
      内组件定宽: 依情况标题和内容(name: <input>)作为以整体还是分离，定宽后，里面内容可以回到%。因为定宽之后，换行内容会整体换
      少量media辅助: 
    9.flex
      justify-content: 使用中间分割的space-between，这样才能更好的控制两边的距离(与外层设置的宽度一致)
      flex-wrap: 自适应很重要的部分,外部不定宽，配合内部组件定宽，保持原大小换行

    
2.vuex | store: 项目大了以后还是需要搭配vuex来说使用的。可能在下的项目还没到巨型，依旧没能体会到mapgetter的作用。
  1.state: 可以理解为一个本地的缓存数据，页面上的动态数据都是state里的内容。
    1.CLEAN_STATE: 先给store定义一个CLEAN_STATE来设置默认值，不需要详细到每个属性，吧外框画出来就行，当需要重置的时候，通过CLEAN_STATE来获取默认值
    2.state: 这里才是运行时的数据
  2.action: 命名应该用动作，获得payload的数据，组装后给sdk，并获取的服务端结果，判断是否出错，然后提交结果集给mutations.
  3.mutations: 用于提交某项内容到state，命名应采用名词为主，而不是一个动作，同时提交的内容应尽可能的简单，少逻辑，直接赋值
    e.g.: 
      commit('detail', data)
      detail(state, e) {
        state.detail = e
      }

2.接口请求 | sdk部分: 这部分认作前端或后端sdk均可，至于sdk写法，各有千秋，总的来说，收集参数，调用地址。
  1.service: 验证必要参数，根据后端，创建formdata或者urlencoded。然后fetch指定接口。
  2.发起请求: 这里先做出一些简单的通用处理，比如参数整理，token加入，content-type处理
    通过接口约定做出的贡献，现在我们可以利用这些约束，简洁我们的代码。
    fetch: html5提供出来的原生接口，可以很好的完成restful请求
      let response = await fetch(...)
      
      如果没有response.ok, response.json()可以视为网络问题提示给用户, 这时一个try-catch + if就可以应对所有接口。把以上status稍加处理，融入自己前端code中，比如{code: -1, msg: statusText}。把他们封装起来，一个简单的库就完成了（既然一个try可以解决的问题，为什么每个调用的接口都要try呢。）

    xmlhttprequest: 比较古老，曾经弄过，用起来不如fetch来的流畅，但为的是得到与fetch同样的结果。与其留下一好一坏的两让人不知所措，不如只留一条明路指引人们。
  3.参数传递: 首选formdata，get，delete采用urlencoded
    post | put: formdata，put对接node无障碍，java端的话比较难搞，需要urlencoded
    get | delete: 一般id，放在路径中就好，filter的内容弄到urlencoded，

3.本地存储: vue自身并没有携带本地存储，而刷新的时候又会清除缓存数据，因此这里需要使用html自带的存储功能
  1.不要使用cookie: 存取困难，过小容量等问题，这已经是一个淘汰的东西了
  2.localstorage | sessionstorage: 网页上，纯本地数据操作其实还是很少的，一两步下来都会获取网络数据，因此，除了权限防止每次输入密码需要存储于localstorage之外，其余建议放置在sessionstorage中
  3.indexeddb: storage尽管扩大了空间，但也并不是能使用全部的用户硬盘，indexeddb作为storage的拓展级使用，但存取相对于storage又繁琐了一些，存储一些base64的图片，防止用户刷新又要重新选择
    存储结构要尽可能简单
    最大的弊端是修改存储结构时，要提供自动删除数据库，或者更新，否则程序不操作，用户也不知道如何手动删
  4.与vuex结合: 运用了vuex之后，数据都从vuex中读取，本地存储在经过vuex的时候以插件方式存入本地，可透明于业务流程

4.router:
  mode: 建议使用history模式，hash模式路径太丑，
    自动刷新: history模式会有代码刷新本页的问题，需要曲线救国，建立空白页面，在要进入该页面时候，使用前一个页面替换router中的目标页面
  name | path: 跳转的时候，虽然name与path都可以，但统一的做法才是最合理的，使用name，path仅仅是用于显示给用户看
    参数: 传递参数采用params，在目标地点使用this.$route.params.xxx获取

5.filter: 是对应数据变化为指定格式，也就是翻译后端数据，而不是实际内容的校验，尽可能做好错误处理，让他使用原本的值显示出来，而不是报了错，用户界面却卡着了。
  全局filter | 局部filter: 尽可能区分好，局部翻译可以采用判断的形式，哪里需要哪里添加
  e.g.: date格式会是比较常见的全局filter: 2017-01-01 -> Jan 01, 2017。 而后端的枚举则是常见的局部filter: BROKEN -> weapon is broken!

2.
  但是总有人会往你的项目里面插各种传统的方式进来，这个时候则需要改造一个这个封装类，使其变为约定格式。在做返回

3.一些比较通用的部件:
  错误提示: 所有调用后端的接口，都会有可能报错的情况，这时应该告诉用户刚才的操作失败了，而不是页面卡在那，要打开控制台才能知道信息。
    一个提示: 有不少模块，都是每收到一个错误调用就弹一个框，这样的用户体验很不好，restful一个页面可能回调很多接口，如果网络不通全死了，用户要点到手指发麻。采用一个提示会出现无法看到全部的错误，但其实这对用户并不重要，他只要知道操作失败就好。这种如果找不到合适的错误提示框，建议还是自己写一个，用vuex替换里面内容。多个错误可以选择往里面增加或直接覆盖，这不重要。
  loading效果: 尽可能的范围小而精确，而不是一整个页面都在loading，点击一个按钮，让按钮变成loading就好，没必要把需要提交的内容也用loading图覆盖起来。
  图片的显示: 不要拉伸，不要拉伸，不要拉伸，真搞不懂拉伸的审美是怎么来的。
    原比例: 图片一定要原比例显示，比例不和规范的，考虑采用剪裁多余部分，或者为不足部分填色
    缩略图: 选择图片后，使用filereader就可以完成缩略图，结合本地存储完成刷新也不会消失，但是不要存在storage里，而应该是db里
    中心图: 显示的中心应该就是图片的中心，而不是左上角开始画图
    列表小图: 上传的时候可以按情况压缩出小图，或者多个模糊图(这个在下没有经验)，默认返回地址都是小图，点击大图的时候才去找到原图显示